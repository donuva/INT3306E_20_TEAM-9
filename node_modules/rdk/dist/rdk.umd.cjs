(function() {
  "use strict";
  try {
    if (typeof document != "undefined") {
      var elementStyle = document.createElement("style");
      elementStyle.appendChild(document.createTextNode("._backdrop_uxwv8_1 {\n  position: fixed;\n  background: var(--color-layer-transparent);\n  top: 0;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  opacity: 0;\n  user-select: none;\n}"));
      document.head.appendChild(elementStyle);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("react"), require("react/jsx-runtime"), require("body-scroll-lock"), require("framer-motion"), require("react-dom"), require("classnames"), require("popper.js")) : typeof define === "function" && define.amd ? define(["exports", "react", "react/jsx-runtime", "body-scroll-lock", "framer-motion", "react-dom", "classnames", "popper.js"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.rdk = {}, global.React, global.jsxRuntime, global.bodyScrollLock, global.framerMotion, global.reactDom, global.classNames, global.PopperJS));
})(this, function(exports2, React, jsxRuntime, bodyScrollLock, framerMotion, reactDom, classNames, PopperJS) {
  "use strict";
  const useExitListener = ({
    ref,
    open = true,
    onClickOutside,
    onEscape
  }) => {
    React.useEffect(() => {
      if (!open) {
        return;
      }
      const handleClick = (event) => {
        if (ref.current && !ref.current.contains(event.target)) {
          onClickOutside == null ? void 0 : onClickOutside(event);
        }
      };
      const handleKey = (event) => {
        if (event.code === "Escape") {
          onEscape == null ? void 0 : onEscape(event);
        }
      };
      if (onClickOutside) {
        document.addEventListener("mousedown", handleClick);
        document.addEventListener("touchstart", handleClick);
      }
      if (onEscape) {
        document.addEventListener("keydown", handleKey);
      }
      return () => {
        if (onClickOutside) {
          document.removeEventListener("mousedown", handleClick);
          document.removeEventListener("touchstart", handleClick);
        }
        if (onEscape) {
          document.removeEventListener("keydown", handleKey);
        }
      };
    }, [ref, onClickOutside, onEscape, open]);
  };
  const OverlayContext = React.createContext({
    close: () => void 0
  });
  let id = 0;
  const genId = () => `ref-${++id}`;
  const useId = (idFromProps) => {
    const [id2] = React.useState(idFromProps || genId());
    return `${id2}`;
  };
  const useUnmount = (fn) => {
    const fnRef = React.useRef(fn);
    fnRef.current = fn;
    React.useLayoutEffect(() => () => fnRef.current(), []);
  };
  const Portal = React.forwardRef(
    ({ children, className, element = "div", onMount, onUnmount }, ref) => {
      const elementRef = React.useRef(null);
      const mounted = React.useRef(false);
      React.useEffect(() => {
        if (className && elementRef.current) {
          elementRef.current.setAttribute("class", `${className} rdk-portal`);
        }
      }, [className, elementRef.current]);
      React.useLayoutEffect(() => {
        elementRef.current = document.createElement(element);
        onMount == null ? void 0 : onMount();
      }, []);
      useUnmount(() => {
        onUnmount == null ? void 0 : onUnmount();
        const ref2 = elementRef.current;
        if (ref2 && document.body.contains(ref2)) {
          document.body.removeChild(ref2);
        }
      });
      React.useImperativeHandle(ref, () => elementRef.current);
      if (!elementRef.current) {
        return null;
      }
      if (!mounted.current) {
        mounted.current = true;
        elementRef.current.classList.add("rdk-portal");
        document.body.appendChild(elementRef.current);
      }
      return reactDom.createPortal(children, elementRef.current);
    }
  );
  const portals = [];
  const START_INDEX = 990;
  const OverlayPortal = React.forwardRef(
    ({ className, children, onMount, onUnmount, appendToBody, id: id2 }, ref) => {
      let portalId = useId(id2);
      const [portalIndex, setPortalIndex] = React.useState(null);
      const [overlayIndex, setOverlayIndex] = React.useState(null);
      const portalRef = React.useRef(null);
      React.useImperativeHandle(ref, () => portalRef.current);
      return /* @__PURE__ */ jsxRuntime.jsx(
        Portal,
        {
          className,
          ref: portalRef,
          appendToBody,
          onMount: () => {
            portals.push(portalId);
            let pidx = portals.indexOf(portalId);
            setPortalIndex(pidx);
            const overlayIdx = START_INDEX + pidx * 2 + 1;
            setOverlayIndex(overlayIdx);
            onMount == null ? void 0 : onMount({
              portalId,
              overlayIndex: overlayIdx,
              portalIndex: pidx,
              backdropIndex: overlayIdx
            });
          },
          onUnmount: () => {
            onUnmount == null ? void 0 : onUnmount();
            portals.splice(portals.indexOf(portalId), 1);
            setPortalIndex(null);
            setOverlayIndex(null);
          },
          children: children({
            overlayIndex,
            portalIndex,
            backdropIndex: overlayIndex,
            portalId
          })
        }
      );
    }
  );
  OverlayPortal.defaultProps = {
    appendToBody: true
  };
  const backdrop = "_backdrop_uxwv8_1";
  const css = {
    backdrop
  };
  const Backdrop = ({
    portalIndex,
    zIndex,
    className,
    onClick
  }) => /* @__PURE__ */ jsxRuntime.jsx(
    framerMotion.motion.div,
    {
      className: classNames(css.backdrop, className),
      initial: { opacity: 0 },
      animate: { opacity: 0.8 - portalIndex / 10 },
      exit: { opacity: 0 },
      style: { zIndex },
      onClick
    }
  );
  Backdrop.defaultProps = {
    zIndex: 998,
    portalIndex: 0
  };
  const GlobalOverlay = ({
    open,
    hasBackdrop = true,
    closeOnEscape = true,
    closeOnBackdropClick = true,
    backdropClassName,
    children,
    onClose
  }) => {
    const overlayRef = React.useRef(null);
    const onBackdropClick = React.useCallback(() => {
      if (closeOnBackdropClick) {
        onClose == null ? void 0 : onClose();
      }
    }, [closeOnBackdropClick, onClose]);
    useExitListener({
      ref: overlayRef,
      open,
      onEscape: () => closeOnEscape && (onClose == null ? void 0 : onClose())
    });
    React.useEffect(() => {
      if (open && children !== void 0) {
        bodyScrollLock.disableBodyScroll(children);
      }
    }, [children, open]);
    return /* @__PURE__ */ jsxRuntime.jsx(OverlayContext.Provider, { value: { close: () => onClose == null ? void 0 : onClose() }, children: /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { children: open && /* @__PURE__ */ jsxRuntime.jsx(OverlayPortal, { ref: overlayRef, children: ({ overlayIndex, portalIndex }) => /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
      hasBackdrop && /* @__PURE__ */ jsxRuntime.jsx(
        Backdrop,
        {
          zIndex: overlayIndex,
          portalIndex,
          onClick: onBackdropClick,
          className: backdropClassName
        }
      ),
      children({ overlayIndex, portalIndex })
    ] }) }) }) });
  };
  const OverlayTrigger = React.forwardRef(
    ({
      children,
      className,
      elementType = "span",
      trigger = ["click"],
      onOpen = () => void 0,
      onClose = () => void 0
    }, ref) => {
      const hasTrigger = React.useCallback(
        (type) => {
          if (Array.isArray(trigger)) {
            return trigger.includes(type);
          } else {
            return type === trigger;
          }
        },
        [trigger]
      );
      const onFocus = React.useCallback(
        (event) => {
          if (hasTrigger("focus")) {
            onOpen({ type: "focus", nativeEvent: event });
          }
        },
        [onOpen, hasTrigger]
      );
      const onBlur = React.useCallback(
        (event) => {
          if (hasTrigger("focus")) {
            onClose({ type: "focus", nativeEvent: event });
          }
        },
        [onClose, hasTrigger]
      );
      const onMouseEnter = React.useCallback(
        (event) => {
          if (hasTrigger("hover")) {
            onOpen({ type: "hover", nativeEvent: event });
          }
        },
        [onOpen, hasTrigger]
      );
      const onMouseLeave = React.useCallback(
        (event) => {
          if (hasTrigger("hover")) {
            onClose({ type: "hover", nativeEvent: event });
          }
        },
        [onClose, hasTrigger]
      );
      const onClick = React.useCallback(
        (event) => {
          if (hasTrigger("click")) {
            onOpen({ type: "click", nativeEvent: event });
          }
          if (!hasTrigger("click")) {
            onClose({ type: "hover", nativeEvent: event });
          }
        },
        [onOpen, onClose, hasTrigger]
      );
      const onContextMenu = React.useCallback(
        (event) => {
          if (hasTrigger("contextmenu")) {
            event.preventDefault();
            onOpen({ type: "contextmenu", nativeEvent: event });
          }
        },
        [onOpen]
      );
      const tabIndex = hasTrigger("focus") ? -1 : void 0;
      const Component = elementType;
      return /* @__PURE__ */ jsxRuntime.jsx(
        Component,
        {
          ref,
          tabIndex,
          onMouseEnter,
          onMouseLeave,
          onFocus,
          onBlur,
          onClick,
          onContextMenu,
          className,
          children
        }
      );
    }
  );
  const usePosition = (reference, { followCursor, placement, modifiers } = {}) => {
    const elementRef = React.useRef(null);
    const popper = React.useRef(null);
    const mouse = React.useRef({
      pageX: 0,
      pageY: 0
    });
    const refPointer = reference.current;
    const popperRef = React.useMemo(() => {
      const refObj = reference;
      if (refObj.current !== void 0) {
        return refObj.current;
      }
      const refElement = reference;
      if (followCursor) {
        return {
          getBoundingClientRect: () => ({
            top: mouse.current.pageY,
            right: mouse.current.pageX,
            bottom: mouse.current.pageY,
            left: mouse.current.pageX,
            width: 0,
            height: 0
          }),
          clientWidth: 0,
          clientHeight: 0
        };
      } else if (refElement && !refElement.getBoundingClientRect) {
        const { top, left, width, height } = reference;
        return {
          getBoundingClientRect: () => ({
            top,
            left,
            width,
            bottom: top - height,
            right: left - width,
            height
          }),
          clientWidth: width,
          clientHeight: height
        };
      }
      return refElement;
    }, [followCursor, reference, refPointer, mouse]);
    React.useLayoutEffect(() => {
      let rqf;
      const onMouseMove = ({ pageX, pageY }) => {
        var _a;
        mouse.current = { pageX, pageY };
        (_a = popper.current) == null ? void 0 : _a.scheduleUpdate();
      };
      const onWindowScroll = () => {
        rqf = requestAnimationFrame(() => {
          var _a;
          (_a = popper.current) == null ? void 0 : _a.scheduleUpdate();
        });
      };
      if (elementRef.current && popperRef) {
        popper.current = new PopperJS(popperRef, elementRef.current, {
          placement: placement || "top",
          modifiers: modifiers || {},
          onCreate: () => {
            window.addEventListener("scroll", onWindowScroll);
            if (followCursor) {
              window.addEventListener("mousemove", onMouseMove);
            }
          }
        });
      }
      return () => {
        var _a;
        if (!elementRef.current) {
          (_a = popper.current) == null ? void 0 : _a.destroy();
          cancelAnimationFrame(rqf);
          window.removeEventListener("scroll", onWindowScroll);
          if (followCursor) {
            window.removeEventListener("mousemove", onMouseMove);
          }
        }
      };
    }, [elementRef.current]);
    React.useLayoutEffect(() => {
      if (popper.current) {
        popper.current.reference = popperRef;
        popper.current.scheduleUpdate();
      }
    }, [popperRef]);
    return [elementRef, popper];
  };
  function CloneElement({
    children,
    element,
    childRef,
    ...rest
  }) {
    const getProjectedProps = React.useMemo(
      () => (props) => {
        const childProps = element.props;
        return Object.keys(props).reduce((acc, key) => {
          const prop = props[key];
          const childProp = childProps[key];
          if (typeof prop === "function" && typeof childProp === "function") {
            acc[key] = (...args) => {
              prop(...args);
              childProp(...args);
            };
          } else if (key === "className") {
            acc[key] = classNames(prop, childProp);
          } else {
            acc[key] = prop;
          }
          return acc;
        }, {});
      },
      [rest]
    );
    if (element === null) {
      return children;
    }
    const ref = childRef ? (node) => {
      if (typeof childRef === "function") {
        childRef(node);
      } else if (ref) {
        childRef.current = node;
      }
    } : void 0;
    const newProps = getProjectedProps(rest);
    return React.cloneElement(element, {
      ...element.props,
      ...newProps,
      children,
      ref
    });
  }
  function useUserSelect(active) {
    React.useEffect(() => {
      if (active) {
        document.body.style.userSelect = "none";
        return () => void (document.body.style.userSelect = "initial");
      }
    }, [active]);
  }
  function useCursor(hovered, onPointerOver = "pointer", onPointerOut = "auto") {
    React.useEffect(() => {
      if (hovered) {
        document.body.style.cursor = onPointerOver;
        return () => void (document.body.style.cursor = onPointerOut);
      }
    }, [hovered]);
  }
  const ConnectedOverlayContent = React.forwardRef(
    ({
      triggerRef,
      children,
      portalClassName,
      closeOnBodyClick,
      closeOnEscape,
      elementType,
      appendToBody,
      followCursor,
      modifiers,
      placement,
      onClose
    }, ref) => {
      const id2 = useId();
      const [overlayIndex, setOverlayIndex] = React.useState(null);
      const [positionRef, popperRef] = usePosition(triggerRef, {
        followCursor,
        modifiers,
        placement
      });
      React.useImperativeHandle(ref, () => ({
        updatePosition: () => {
          var _a;
          (_a = popperRef == null ? void 0 : popperRef.current) == null ? void 0 : _a.scheduleUpdate();
        }
      }));
      const onClickOutside = React.useCallback(
        (event) => {
          if (closeOnBodyClick) {
            let ref2 = null;
            if (triggerRef.current) {
              ref2 = triggerRef.current;
            } else if (triggerRef.contains !== void 0) {
              ref2 = triggerRef;
            }
            const container = event.target.closest(".rdk-portal");
            const isLast = portals.indexOf(id2) === portals.length - 1;
            if (!(ref2 == null ? void 0 : ref2.contains(event.target)) && (isLast || !container)) {
              onClose == null ? void 0 : onClose(event);
            }
          }
        },
        [closeOnBodyClick, onClose]
      );
      const onEscape = React.useCallback(() => {
        if (closeOnEscape) {
          onClose == null ? void 0 : onClose();
        }
      }, [closeOnEscape, onClose]);
      useExitListener({
        open: true,
        ref: positionRef,
        onClickOutside,
        onEscape
      });
      React.useEffect(() => {
        if (positionRef && overlayIndex) {
          positionRef.current.style.zIndex = overlayIndex;
        }
      }, [positionRef.current, overlayIndex]);
      return /* @__PURE__ */ jsxRuntime.jsx(
        OverlayPortal,
        {
          id: id2,
          ref: positionRef,
          className: portalClassName,
          elementType,
          appendToBody,
          onMount: (event) => setOverlayIndex(event.overlayIndex),
          onUnmount: () => setOverlayIndex(null),
          children
        }
      );
    }
  );
  ConnectedOverlayContent.defaultProps = {
    closeOnBodyClick: true,
    closeOnEscape: true,
    appendToBody: true,
    placement: "bottom"
  };
  const ConnectedOverlay = React.forwardRef(
    ({
      reference,
      children,
      open,
      content,
      triggerElement,
      triggerClassName,
      trigger,
      onOpen,
      onClose,
      ...rest
    }, ref) => {
      const mounted = React.useRef(false);
      const overlayTriggerRef = React.useRef(null);
      const contentRef = React.useRef(null);
      const triggerRef = reference || overlayTriggerRef;
      React.useImperativeHandle(ref, () => ({
        updatePosition: () => {
          var _a;
          (_a = contentRef.current) == null ? void 0 : _a.updatePosition();
        }
      }));
      React.useEffect(() => {
        if (mounted.current) {
          if (!open) {
            onClose == null ? void 0 : onClose();
          } else {
            onOpen == null ? void 0 : onOpen();
          }
        }
      }, [open]);
      React.useEffect(() => {
        if (!mounted.current) {
          mounted.current = true;
        }
      });
      const providerValue = React.useMemo(
        () => ({
          close: () => onClose == null ? void 0 : onClose()
        }),
        [onClose]
      );
      return /* @__PURE__ */ jsxRuntime.jsxs(OverlayContext.Provider, { value: providerValue, children: [
        children && /* @__PURE__ */ jsxRuntime.jsx(React.Fragment, { children: trigger ? /* @__PURE__ */ jsxRuntime.jsx(
          OverlayTrigger,
          {
            elementType: triggerElement,
            ref: overlayTriggerRef,
            className: triggerClassName,
            trigger,
            onOpen,
            onClose,
            children
          }
        ) : children }),
        /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { children: open && /* @__PURE__ */ jsxRuntime.jsx(
          ConnectedOverlayContent,
          {
            ...rest,
            ref: contentRef,
            triggerRef,
            onClose,
            children: content
          }
        ) })
      ] });
    }
  );
  ConnectedOverlay.defaultProps = {
    trigger: "click"
  };
  const useOverlay = () => {
    const context = React.useContext(OverlayContext);
    if (context === void 0) {
      throw new Error(
        "`useOverlay` hook can only be used inside a overlay component."
      );
    }
    return context;
  };
  exports2.Backdrop = Backdrop;
  exports2.CloneElement = CloneElement;
  exports2.ConnectedOverlay = ConnectedOverlay;
  exports2.ConnectedOverlayContent = ConnectedOverlayContent;
  exports2.GlobalOverlay = GlobalOverlay;
  exports2.OverlayContext = OverlayContext;
  exports2.OverlayPortal = OverlayPortal;
  exports2.OverlayTrigger = OverlayTrigger;
  exports2.Portal = Portal;
  exports2.portals = portals;
  exports2.useCursor = useCursor;
  exports2.useExitListener = useExitListener;
  exports2.useId = useId;
  exports2.useOverlay = useOverlay;
  exports2.usePosition = usePosition;
  exports2.useUserSelect = useUserSelect;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
});
//# sourceMappingURL=rdk.umd.cjs.map
